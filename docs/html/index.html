<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Vienna Game AI Library: ViennaGameAILibrary</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Vienna Game AI Library<span id="projectnumber">&#160;v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ViennaGameAILibrary </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__d_1_2_uni_vie_2_sem_015_2_master_2_vienna_game_a_i_library_2_r_e_a_d_m_e"></a> Vienna Game AI Library is a single-header, comprehensive C++ library that encompasses popular AI algorithms to be used in creating 2D Real-Time Strategy games with a focus on Non-Player Character management.</p>
<p>The library was created due to the lack of toolkits written in the C++ programming language that contains all algorithms required to develop RTS games. It started as a Master thesis by Lavinia-Elena Lehaci under the supervision of Univ.-Prof. Dipl.-Ing. Dr. Helmut Hlavacs. This project is intended to be worked on during future theses and it will be expanded by other algorithms.</p>
<p>From path finding, to state machines, decision trees and steering algorithms, Vienna Game AI Library should encompass everything a game developer might need in creating a 2D RTS game. In order to show its efficiency and applicability, each implemented feature is showcased in a respective demo created with the help of the <a href="https://github.com/raysan5/raylib">raylib</a> library.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Project structure</h1>
<ul>
<li><em>assets</em> - Resource folder containing media files used for <code>README.md</code></li>
<li><em>docs</em> - Code documentation</li>
<li><em>Demo</em><ul>
<li><a href="https://github.com/raysan5/raylib">raylib</a></li>
<li><em>src</em> - Source folder containing the code for the demos</li>
<li><em>res</em> - Resource folder containing assets used in demos</li>
<li><code>CMakeLists.txt</code></li>
</ul>
</li>
<li><em>include</em> - <code><a class="el" href="_vienna_game_a_i_library_8hpp.html">ViennaGameAILibrary.hpp</a></code></li>
<li><code>build_demo_win.bat</code> - Script to build the project on Windows</li>
<li><code>run_demo_win.bat</code> - Script to run the project on Windows</li>
<li><code>CMakeLists.txt</code></li>
<li><code>README.md</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Setup - Windows</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Prerequisites</h2>
<ul>
<li><a href="https://www.doxygen.nl/index.html">Doxygen</a></li>
<li><a href="https://ninja-build.org/">Ninja</a></li>
<li><a href="https://www.msys2.org/">Msys2</a> - CMake and Clang need to be installed through msys2.<ul>
<li>CMake (minimum version required: 3.28.1)</li>
<li>Clang</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Build and run the project</h2>
<ol type="1">
<li>Clone the project.</li>
<li>Run <code>git submodule init</code> and <code>git submodule update</code> to fetch raylib.</li>
<li>Update the location of <code>clang++.exe</code> in the <code>build_demo_win.bat</code> file based on the location of the msys2 folder.</li>
<li>Add <em>msys64/ucrt64/bin</em> and <em>doxygen/bin</em> to the path environment variable.</li>
<li>Run <code>build_demo_win.bat</code> to build the project. The output will be stored in the build folder.</li>
</ol>
<p>Make sure Clang and Ninja are used by this project. Once the build process starts, the first two lines should be the following: </p><div class="fragment"><div class="line">-- Building for: Ninja</div>
<div class="line">-- The CXX compiler identification is Clang 17.0.6 // or any other version</div>
</div><!-- fragment --><ol type="1">
<li>Run <code>run_demo_win.bat</code> to start the project.</li>
</ol>
<h2><a class="anchor" id="autotoc_md5"></a>
To run different demos</h2>
<p>In <em>Demo/<code>CMakeLists.txt</code></em>, change the path of the .cpp file that you want to run. </p><div class="fragment"><div class="line">add_executable(Demo src/demo_PathFinding.cpp ${PROJECT_SOURCE_DIR}/include/ViennaGameAILibrary.hpp)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Code documentation</h1>
<p>Documentation is generated using Doxygen. To see it, open <code>index.html</code> which can be found in the <em>docs</em> folder.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
How to use each feature the library provides</h1>
<blockquote class="doxtable">
<p>&zwj;<b>Note</b> : When implementing any features, keep in mind that you will need to transform the library coordinates into screen coordinates. The demos contain examples of how to do this. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md8"></a>
1. <b>Data structures and data types</b></h2>
<p><em>Vienna Game AI Library</em> uses two custom made vectors: <code>Vec2ui</code> and <code>Vec2f</code>. Both represent 2D vectors, with <code>Vec2ui</code> made of unsigned integers, and <code>Vec2f</code> of floats. The navigation mesh uses <code>Vec2ui</code>, while Boids use <code>Vec2f</code> due to required mathematical operations. Other data structures used in the library are <code>std::vector</code> and <code>std::unordered_map</code>.</p>
<p>The data types used in the library are: <code>uint32_t</code>, <code>uint64_t</code>, <code>int32_t</code> and <code>float</code>. Each has a typedef declaration to make the code more readable (<code>uint32_t</code> -&gt; <code>ui32</code>, <code>uint64_t</code> -&gt; <code>ui64</code>, <code>int32_t</code> -&gt; <code>i32</code>, <code>float</code> -&gt; <code>f32</code>).</p>
<p>There are custom structs also defined in the library. The <code>NavMesh</code> class is represented by a <code>std::vector</code> of <code>NodeData</code> objects. If geometric preprocessing is used for path finding, the <code>Region</code> struct is also used to store the nodes inside each region, and <code>RegionList</code> to manage all regions.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
2. <b>Path finding</b></h2>
<blockquote class="doxtable">
<p>&zwj;Demo example: <em>Demo/src/demo_Pathfinding.cpp</em> </p>
</blockquote>
<ul>
<li>Create a navigation mesh</li>
</ul>
<p>To generate it randomly, pass the desired width and height, as well as a percentage which will limit the amount of obstacles spawned within the navigation mesh. To load it from a file, simply call the constructor with the file path as the argument. </p><div class="fragment"><div class="line">// Generate it randomly</div>
<div class="line">VGAIL::NavMesh* navmesh = new VGAIL::NavMesh(navmeshWidth, navmeshHeight, 30.0f);</div>
<div class="line"> </div>
<div class="line">// Or load it from a file</div>
<div class="line">VGAIL::NavMesh* navmesh = new VGAIL::NavMesh(&quot;Demo/res/navmesh.txt&quot;);</div>
</div><!-- fragment --><p> The navmesh file can be created either manually or by the game itself. The file has the following structure: </p><div class="fragment"><div class="line">navmeshWidth</div>
<div class="line">navmeshHeight</div>
<div class="line">owwwwoowwowww...</div>
</div><!-- fragment --><p> Both <code>navmeshWidth</code> and <code>navmeshHeight</code> need to be positive integers. The third line describes the pattern of the navigation mesh, where <code>w</code> is a walkable area and <code>o</code> is an obstacle. Make sure that the number of characters are equal to <code>navmeshWidth</code> * <code>navmeshHeight</code>.</p>
<p>There is also the option to save a randomly generated navmesh. This can be done by calling <code>saveToFile(const std::string&amp; filepath)</code> (<em>ViennaGameAILibrary</em> : 453-466) and by passing a filepath. If the file doesn't exist, it will be created automatically.</p>
<ul>
<li>Create start and end positions for the A* algorithm</li>
</ul>
<p>The start and end positions need to be <code>Vec2ui</code>. Inside the application, they can be converted to screen coordinates by multiplying to a number of your choice. <em>See the demo for pathfinding for more details, specifically calculations that use <code>gridStride</code></em>. </p><div class="fragment"><div class="line">VGAIL::Vec2ui startPosition = VGAIL::Vec2ui(1, 1);</div>
<div class="line">VGAIL::Vec2ui endPosition = VGAIL::Vec2ui(15, 15);</div>
</div><!-- fragment --><ul>
<li>Optional: start geometric preprocessing</li>
</ul>
<p>While A* ensures finding the shortest path, it sometimes can be quite slow. In video games, it is preferred that the path is retrieved as fast as possible, so if that means that the path returned is not the shortest one, it will most likely not have a big impact on the game. A path that is found fast but is not necessarily the shortest from all options, is called an optimal path. Geometric preprocessing ensures finding an optimal path, so not necessarily the shortest one.</p>
<p>This process can be called while setting up the application (before the game loop) in order to perform all calculations before the application starts. It can be done in two ways: with single or multiple threads. The call for this process is as follows: </p><div class="fragment"><div class="line">void preprocess(bool multithreading = false, ui32 numThreads = 4)</div>
</div><!-- fragment --><p> The boolean specifies whether to use multithreading (default: false), and <code>numThreads</code> is the number of threads needed to run in parallel (default: 4).</p>
<p>This process will work on the Regions defined when the navmesh is created (see <em>ViennaGameAILibrary</em> : 514-537). The number of regions depends on the navmesh size, and by default they are set to each contain 9 * 9 nodes (9 on the <em>x</em> axis, 9 on the <em>y</em> axis). Depending on the navmesh size, this can be changed accordingly to maximize performance. If multithreading is used, each thread receives <code>totalNumberOfRegions / numThreads</code> regions.</p>
<p>The following picture shows how the regions would look like on top of the demo for path finding by using the default values. Each orange square represents a region.</p>
<div align="center"> <img src="assets/pathfinding.jpg" alt="" class="inline"/> </div><p>During this process, the <code>AStar</code> method is called to calculate the distance between each nodes and each region. Therefore, at the end of the process, the <code>m_adjList</code> from the <code>NavMesh</code> class will contain the best path from one node to a region at <code>m_adjList[nodeIndex][regionID]</code>.</p>
<ul>
<li>Find the most optimal path</li>
</ul>
<div class="fragment"><div class="line">// Without geometric preprocessing</div>
<div class="line">std::vector&lt;VGAIL::Vec2ui&gt; path = navmesh-&gt;findPath(startPosition, endPosition);</div>
<div class="line"> </div>
<div class="line">// Using geometric preprocessing with/without multithreading</div>
<div class="line">std::vector&lt;VGAIL::Vec2ui&gt; path = navmesh-&gt;findPreprocessedPath(startPosition, endPosition);</div>
</div><!-- fragment --><p>The <code>findPath()</code> method calculates the path by using A*, while <code>findPreprocessedPath()</code> retrieves the stored path if geometric preprocessing has been done.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
3. <b>Decision trees</b></h2>
<blockquote class="doxtable">
<p>&zwj;Demo example: <em>Demo/src/demo_DecisionTree.cpp</em> </p>
</blockquote>
<ul>
<li>Create the decision tree</li>
</ul>
<div class="fragment"><div class="line">VGAIL::DecisionTree tree;</div>
</div><!-- fragment --><ul>
<li>For each node of the tree (and recursively its children) a custom class needs to be implemented to delegate actions to its children based on some criteria.</li>
</ul>
<p>Each decision node needs to implement its own <code>makeDecision(float dt)</code> method, in which it either delegates further actions to its children or implements game logic. In the example below, the <code>isEnemyClose</code> class is responsible for checking the distance between the player and an enemy. Depending on this distance, it calls a child decision node. </p><div class="fragment"><div class="line">// Example: a character makes decisions based on the distance to an enemy</div>
<div class="line">class isEnemyClose : public VGAIL::DecisionNode</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">    isEnemyClose(VGAIL::Vec2f&amp; enemyPos)</div>
<div class="line">        : enemyPos(enemyPos) {}</div>
<div class="line"> </div>
<div class="line">    ~isEnemyClose() {}</div>
<div class="line"> </div>
<div class="line">    void makeDecision(float dt) override</div>
<div class="line">    {</div>
<div class="line">        float dist = VGAIL::distance(position, enemyPos);</div>
<div class="line">        if (dist &lt;= 100.0f)</div>
<div class="line">        {</div>
<div class="line">            getChild(0).makeDecision(dt);</div>
<div class="line">        }</div>
<div class="line">        else if (dist &gt; 100.0f &amp;&amp; dist &lt; 150.0f)</div>
<div class="line">        {</div>
<div class="line">            getChild(1).makeDecision(dt);</div>
<div class="line">        }</div>
<div class="line">        else</div>
<div class="line">        {</div>
<div class="line">            getChild(2).makeDecision(dt);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    VGAIL::Vec2f position;</div>
<div class="line">    VGAIL::Vec2f&amp; enemyPos;</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>Create the root of the tree</li>
</ul>
<div class="fragment"><div class="line">// Example for the code shown above</div>
<div class="line">VGAIL::DecisionNode&amp; root = tree.createRoot&lt;isEnemyClose&gt;(...args);</div>
</div><!-- fragment --><p>→ <code>...args</code> refers to any arguments that need to be passed to the custom class.</p>
<ul>
<li>Add nodes and their children</li>
</ul>
<div class="fragment"><div class="line">VGAIL::DecisionNode&amp; node1 = root.addChild&lt;Class1&gt;(...args);</div>
<div class="line">VGAIL::DecisionNode&amp; node2 = root.addChild&lt;Class2&gt;(...args);</div>
<div class="line">...</div>
<div class="line">VGAIL::DecisionNode&amp; node1_child1 = node1.addChild&lt;ClassX&gt;(...args);</div>
<div class="line">...</div>
</div><!-- fragment --><p>The order in which the child nodes are instantiated is important, as it will matter when calling it from the parent node. In the example above, in the <code>isEnemyClose</code> class, <code>getChild(0)</code> will call the first child node that was created, in this case <code>node1_child1</code>.</p>
<ul>
<li>In the game loop, update the decision tree</li>
</ul>
<div class="fragment"><div class="line">tree.update(deltaTime);</div>
</div><!-- fragment --><p>In the example from <em>demo_DecisionTree.cpp</em>, both characters have their own decision tree and each chosen decision is displayed every frame on the screen.</p>
<div align="center"> <img src="assets/decisionTreeDemo.png" alt="" class="inline"/> </div><p>The logic behind the decision trees is displayed in the following picture.</p>
<div align="center"> <img src="assets/decisionTree.jpg" alt="" class="inline"/> </div><p>In this example, the decision nodes are represented by the rectangular objects (<em>isGuardClose</em>, <em>isBurglarClose</em>, etc.).</p>
<h2><a class="anchor" id="autotoc_md11"></a>
4. <b>State machines</b></h2>
<blockquote class="doxtable">
<p>&zwj;Demo example: <em>Demo/src/demo_StateMachine.cpp</em> </p>
</blockquote>
<ul>
<li>Create a state machine</li>
</ul>
<div class="fragment"><div class="line">VGAIL::StateMachine stateMachine;</div>
</div><!-- fragment --><ul>
<li>Create states</li>
</ul>
<div class="fragment"><div class="line">VGAIL::State* walking = stateMachine.createState();</div>
<div class="line">VGAIL::State* sleeping = stateMachine.createState();</div>
</div><!-- fragment --><ul>
<li>Implement the state in the update callback</li>
</ul>
<p>The <code>onUpdateCallback()</code> method is called every frame, so the game logic for the state should be implemented in this method. </p><div class="fragment"><div class="line">walking-&gt;onUpdateCallback = [&amp;](float deltaTime) {</div>
<div class="line">    // walk, play walking animation...</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>If needed, add actions at the start and/or end of a state</li>
</ul>
<p>Each state has <code>onEnterCallback()</code> and <code>onExitCallback()</code> methods. <code>onEnterCallback()</code> is called at the beginning of a state, and <code>onExitCallback()</code> is called at the end when the state is completed. </p><div class="fragment"><div class="line">sleeping-&gt;onEnterCallback = [&amp;]() {</div>
<div class="line">    // play sleeping animation</div>
<div class="line">};</div>
</div><!-- fragment --><ul>
<li>Create transitions between states</li>
</ul>
<p>Transitions are responsible with changing the current state by checking a certain condition. If the condition is met, the <code>onEnterCallback()</code> of the next state is called. If <code>onEnterCallback()</code> is not implemented, it will go to <code>onUpdateCallback()</code>. </p><div class="fragment"><div class="line">walking-&gt;addTransition(sleeping, [&amp;]() {</div>
<div class="line">    return health &lt;= 2;</div>
<div class="line">});</div>
</div><!-- fragment --><p> In the example above, the transition is responsible with choosing the correct state based on the character's health. Once the health is less than or equal to 2, it will trigger the <code>onEnterCallback()</code> / <code>onUpdateCallback()</code> method of the <em>sleeping</em> state.</p>
<ul>
<li>In the game loop, update the state machine</li>
</ul>
<div class="fragment"><div class="line">stateMachine.update(deltaTime);</div>
</div><!-- fragment --><p>This method is responsible with managing the states and transitions between them every frame.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
5. <b>Steering behaviors</b></h2>
<p>Demo examples:</p>
<p>&gt;<em>Demo/src/demo_SteeringBehaviors.cpp</em> (all steering behaviors combined)</p>
<p>&gt;<em>Demo/src/SteeringBehaviors</em> (each steering behavior with its own demo)</p>
<p>The steering behaviors can only be used on instances of the <code>VGAIL::Boids</code> class.</p>
<ul>
<li>Create the boid</li>
</ul>
<p>Each boid needs a position, a velocity and a maximum speed when instantiated. By default, the maximum speed is 5.0f, and the position and velocity are both 0. Each boid also has an id, used in the flocking algorithm, but since it is not relevant for the rest of the steering behaviors, it is set to 0 by default.</p>
<div class="fragment"><div class="line">VGAIL::Boid* agent = new VGAIL::Boid(position, velocity, maxSpeed);</div>
</div><!-- fragment --><ul>
<li>Calculate the steering force </li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
5.1. <b>Seek</b></h3>
<blockquote class="doxtable">
<p>&zwj;Demo example: <em>Demo/src/SteeringBehaviors/demo_SeekAndFlee.cpp</em> </p>
</blockquote>
<p>The <em>seek</em> steering behavior allows for a realistic movement towards a given target. The method takes as arguments <code>targetPosition</code> (<code>Vec2f</code> - position of the target) and <code>maxAcceleration</code> (<code>float</code> - the maximum rate at which the velocity can change per unit of time).</p>
<div class="fragment"><div class="line">VGAIL::Vec2f steeringForce = agent-&gt;seek(targetPosition, maxAcceleration);</div>
</div><!-- fragment --><div align="center"> <img src="assets/seek.gif" alt="" class="inline"/> </div><p>In the example above, the blue object is seeking the player (yellow object).</p>
<h3><a class="anchor" id="autotoc_md14"></a>
5.2. <b>Flee</b></h3>
<p>&gt; Demo example: <em>Demo/src/SteeringBehaviors/demo_SeekAndFlee.cpp</em></p>
<p>The <em>flee</em> steering behavior is the opposite of <em>seek</em>, as it moves away from and not towards a target. The arguments are the same as for the <em>seek</em> behavior.</p>
<p><code> <a class="el" href="struct_v_g_a_i_l_1_1_vec2f.html" title="Custom 2D vector of floats.">VGAIL::Vec2f</a> steeringForce = agent-&gt;flee(targetPosition, maxAcceleration); </code></p>
<div align="center"> <img src="assets/flee.gif" alt="" class="inline"/> </div><p>In the example above, the green object is fleeing the player (yellow object), while also staying inside the borders of the window.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
5.3. <b>Arrive</b></h3>
<p>&gt; Demo example: <em>Demo/src/SteeringBehaviors/demo_Arrive.cpp</em></p>
<p>The <em>arrive</em> steering behavior is responsible for slowing down the character before it reaches its destination such that it can stop smoothly. If the character is far from the destination, it uses the <em>seek</em> behavior to move towards it, and once it gets close enough, it starts slowing down until it eventually reaches the target.</p>
<p>In the library, it takes three arguments: <code>targetPosition</code> (<code>Vec2f</code> - destination), <code>slowRadius</code> (<code>float</code> - the radius of the slowing area), and <code>maxAcceleration</code> (<code>float</code> - the maximum rate at which the velocity can change per unit of time).</p>
<p><code> <a class="el" href="struct_v_g_a_i_l_1_1_vec2f.html" title="Custom 2D vector of floats.">VGAIL::Vec2f</a> steeringForce = agent-&gt;arrive(targetPosition, slowRadius, maxAcceleration); </code></p>
<div align="center"> <img src="assets/arrive.gif" alt="" class="inline"/> </div><p>In this example, the blue object uses the <em>arrive</em> steering behavior to get to the green dot and it slows down once it enters the area shown by the red circle.</p>
<p>This behavior is useful in cases when it is important to show that a character reached its target destination. The <em>seek</em> behavior, used alone, will make the character bounce back and forth around the target, but the <em>arrive</em> behavior will ensure that the character will not move through the target by slowing down so it can stop once it reaches it.</p>
<h3><a class="anchor" id="autotoc_md16"></a>
5.4. <b>Pursue</b></h3>
<p>&gt; Demo example: <em>Demo/src/SteeringBehaviors/demo_PursueAndEvade.cpp</em></p>
<p><em>Pursue</em> is very similar to the <em>seek</em> behavior in the sense that it follows a given target. The difference is that the pursuer tries to "catch" the target by anticipating its movement, which is done by predicting the target's future positions. That is done such that it avoids taking unnecessary paths as it will estimate where the target will be within the next few seconds and move towards that new position.</p>
<p>The method takes three arguments: <code>targetBoid</code> (<code>Boid</code> - the target to pursue), <code>maxAcceleration</code> (<code>float</code> - the maximum rate at which the velocity can change per unit of time), and <code>maxPrediction</code> (<code>float</code> - the maximum prediction time used to estimate where the target will be in the future).</p>
<p><code> <a class="el" href="struct_v_g_a_i_l_1_1_vec2f.html" title="Custom 2D vector of floats.">VGAIL::Vec2f</a> steeringForce = agent-&gt;pursue(targetBoid, maxAcceleration, maxPrediction); </code></p>
<div align="center"> <img src="assets/pursue.gif" alt="" class="inline"/> </div><p>In this example, the purple object is following the player (yellow object).</p>
<h3><a class="anchor" id="autotoc_md17"></a>
5.5. <b>Evade</b></h3>
<p>&gt; Demo example: <em>Demo/src/SteeringBehaviors/demo_PursueAndEvade.cpp</em></p>
<p><em>Evade</em> is the opposite of <em>pursue</em>, as it uses prediction to "escape" a given target. The same arguments as for the <em>pursue</em> behavior are used.</p>
<p><code> <a class="el" href="struct_v_g_a_i_l_1_1_vec2f.html" title="Custom 2D vector of floats.">VGAIL::Vec2f</a> steeringForce = agent-&gt;evade(targetBoid, maxAcceleration, maxPrediction); </code></p>
<div align="center"> <img src="assets/evade.gif" alt="" class="inline"/> </div><p>In this example, the pink object is following the player (yellow object), while also staying inside the borders of the window.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
5.6. <b>Wander</b></h3>
<p>&gt; Demo example: <em>Demo/src/SteeringBehaviors/demo_Wander.cpp</em></p>
<p>The <em>wander</em> steering behavior produces a natural-looking movement of a character "casually" walking around. Its implementation, following Craig Reynold's proposal, uses a circle defined in front of the character from which the steering force is calculated.</p>
<div align="center"> <img src="assets/wander.jpg" alt="" class="inline"/> </div><p>In the picture above, the character is represented by the triangle. The circle defined in this behavior is set at a <code>circleDistance</code> from the character and has a <code>circleRadius</code>. Every frame, a random point is chosen from the outline of the circle which will the new direction the character will need to steer towards. In order to avoid strong flickering (the character moving abruptly left and right), a <code>displacementRange</code> is given which will be responsible for limiting the interval from which this random point is chosen. As for the previous steering behaviors, <code>maxAcceleration</code> is the maximum rate at which the velocity can change per unit of time.</p>
<p><code> <a class="el" href="struct_v_g_a_i_l_1_1_vec2f.html" title="Custom 2D vector of floats.">VGAIL::Vec2f</a> steeringForce = agent-&gt;wander(circleDistance, circleRadius, displaceRange, maxAcceleration); </code></p>
<div align="center"> <img src="assets/wander.gif" alt="" class="inline"/> </div><p>In this example, the red line is the character's velocity which changes every frame depending on the randomly chosen point.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
5.7. <b>Steer</b></h3>
<p>The <code>getRotationInDegrees()</code> method from the <code>Boid</code> class calculates the rotation of the boid in degrees and can be used to show in which direction the boid is moving. Steering is already implemented in each already mentioned behavior, therefore this method is only needed for rendering.</p>
<p>Each texture needs a texture rotation as per the <code>DrawTexturePro</code> method from <em>raylib</em>. In the demos for the steering behaviors, the <code>getRotationInDegrees()</code> method is simply called when drawing the texture on the screen such that the texture is always facing the direction it is moving.</p>
<p>The library also provides implementation for the three steering behaviors used usually in flocking (<em>separation</em>, <em>alignment</em>, <em>cohesion</em>). They are detailed in the next section.</p><ul>
<li>Apply the steering force and update the position.</li>
</ul>
<div class="fragment"><div class="line">agent-&gt;applySteeringForce(steeringForce);</div>
<div class="line">agent-&gt;updatePosition(deltaTime);</div>
</div><!-- fragment --><p>→ <code>steeringForce</code> is the output vector resulted from any of the methods shown above.</p>
<p>Please note that the <code>updatePosition()</code> method must be called after applying the steering force, otherwise the boid's position will not change according to the new calculations.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
6. <b>Flocking</b></h2>
<p>The flocking behavior only works on <code><a class="el" href="class_v_g_a_i_l_1_1_boid.html">VGAIL::Boid</a></code> instances. The implementation follows Craig Reynolds's proposal.</p>
<ul>
<li>Create the flock</li>
</ul>
<p>This is responsible for managing all boids such that they respect the three steering behaviors: separation, alignment and cohesion.</p>
<div class="fragment"><div class="line">VGAIL::Flocking* flock = new VGAIL::Flocking();</div>
</div><!-- fragment --><p>Separation ensures that the boids do not overlap, thus steers the boids away from one another to avoid crowding. Alignment is responsible for calculating the average velocity of the boids and steer them accordingly. Cohesion is steering the boids towards the average position of the boids from the same group.</p>
<ul>
<li>Set the separation and perception ranges</li>
</ul>
<div class="fragment"><div class="line">flock-&gt;setRanges(separationRange, perceptionRange);</div>
</div><!-- fragment --><p>→ <code>separationRange</code> is used in the <code>separation</code> behavior. Each boid needs such a range to avoid colliding with other boids. The algorithm checks for each boid if any fellow boid is at a distance smaller than this range, in which case it will steer the boid away such that it creates space between them.</p>
<p>→ <code>perceptionRange</code> is used in both <code>alignment</code> and <code>cohesion</code>. This range represents the distance within which a boid considers neighboring boids, or in simpler terms, how far a boid "sees" other nearby boids. Once other boids are in this range, the algorithm will use <code>alignment</code> and <code>cohesion</code> to match its velocity to the other boids' velocity and to position the boid within the group.</p>
<ul>
<li>Add boids to the flock</li>
</ul>
<p>To add a boid to the flock, simply call the following method:</p>
<div class="fragment"><div class="line">flock-&gt;addBoid(position, velocity, minSpeed, maxSpeed);</div>
</div><!-- fragment --><p>Both <code>position</code> and <code>velocity</code> are <code>Vec2f</code>, while <code>minSpeed</code> and <code>maxSpeed</code> are <code>float</code>.</p>
<ul>
<li>In the game loop, update the flock</li>
</ul>
<div class="fragment"><div class="line">flock-&gt;update(deltaTime, avoidFactor, matchingFactor, centeringFactor);</div>
</div><!-- fragment --><p>To update the flock, <code>deltaTime</code> is needed such that smooth movement is ensured. On top of that, three different factors are required as well.</p>
<p>→ <code>avoidFactor</code> determines how strongly boids react to possible collisions.</p>
<p>→ <code>matchingFactor</code> determines how strongly boids steer to match the average velocity of their neighbours.</p>
<p>→ <code>centeringFactor</code> determines how strongly boids steer to match the average position of their neighbours.</p>
<div align="center"> <img src="assets/flocking.gif" alt="" class="inline"/> </div><h1><a class="anchor" id="autotoc_md21"></a>
Resources</h1>
<ul>
<li>Textures<ul>
<li><a href="https://kenney.nl/assets/platformer-pack-medieval">https://kenney.nl/assets/platformer-pack-medieval</a></li>
<li><a href="https://kenney.nl/assets/toon-characters-1">https://kenney.nl/assets/toon-characters-1</a></li>
<li><a href="https://kenney.nl/assets/medieval-rts">https://kenney.nl/assets/medieval-rts</a></li>
<li><a href="https://kenney.nl/assets/shape-characters">https://kenney.nl/assets/shape-characters</a></li>
<li><a href="https://kenney.nl/assets/animal-pack-redux">https://kenney.nl/assets/animal-pack-redux</a></li>
<li><a href="https://kenney.nl/assets/tiny-town">https://kenney.nl/assets/tiny-town</a></li>
<li><a href="https://p3d.in/JeRJE">https://p3d.in/JeRJE</a></li>
</ul>
</li>
<li>Fonts<ul>
<li><a href="https://www.dafont.com/pixelplay.font">https://www.dafont.com/pixelplay.font</a></li>
<li><a href="https://www.dafont.com/sunny-spells-basic.font">https://www.dafont.com/sunny-spells-basic.font</a> </li>
</ul>
</li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
